#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <cmath>
#include "fftw3.h"
#include "TObject.h"
#include "TCanvas.h"
#include "TH2.h"
#include "TGraph.h"
#include "TArc.h"
#include "TLine.h"
#include "TText.h"
#include "TGraphErrors.h"
#include "TApplication.h"
#include "TROOT.h"
#include "TPostScript.h"
#include "TStyle.h"
#include "TMinuit.h"
#include "TMarker.h"
#include "TText.h"
#include "TFile.h"
#include "TNtuple.h"
#include "TRandom.h"
#include "mag_pa_tool.h"
#include "paramanage.h"
#include "radiation.h"
#include "fft_fitter.h"

using namespace std;

struct t_parameter parameter;

int main(int argc, char* argv[])
{
  TApplication theApp("App",&argc,argv);
  TROOT rsession("test", "test");

  TString cardname = theApp.Argv(1);
  char cdummy[1000];

  //use Adipark parameter-reading routine to read control card
  char *parameter_filename = new char[255];
  strcpy(parameter_filename,cardname.Data());
  init_parameters();
  int parameter_file_found = 0;
  if (load_init_data(parameter_filename)==0) 
    {
      
      char *parameter_filename_sub = new char[255];
      cout << "Try parameter file w/o suffix: ";
      strncat(parameter_filename_sub,parameter_filename,strlen(parameter_filename)-4);
      cout << parameter_filename_sub << endl;	
      if (load_init_data(parameter_filename_sub) == 0)
	{
	  cout << "Try parameter file w/o point: ";
	  strcpy(parameter_filename_sub,"");
	  strncat(parameter_filename_sub,parameter_filename,strlen(parameter_filename)-1);
	  cout << parameter_filename_sub << endl;
	  if (load_init_data(parameter_filename_sub) == 0)
	    {
	      cout << endl << "ERROR: missing some settings in INI-file!";
	      cout << endl << endl << flush;
	    }
	  else 
            {
              parameter_file_found = 1;
	      cardname.Resize(strlen(parameter_filename)-1);
            }
	}
      else  
        {
          parameter_file_found = 1;
	  cardname.Resize(strlen(parameter_filename)-4);
        }
    }
  else  parameter_file_found = 1;
  
  //open run file
  TString runname = cardname+TString(".run"); 
  TString ininame = cardname+TString(".ini"); 

  ifstream runfile;
  runfile.open(runname.Data());
  runfile.getline(cdummy,1000); //read and discard header line
  int repeat;
  double xi,yi,zi,ekin,thetai,phii,mass,charge;

  double x,y,z,r,ep,ek,epar,eperp,egain,eloss,b,phi,t,scatt,wq;

  int i=1;
  //for each line of runfile we expect a track 
  TString rootname = cardname+TString(".root");
  TFile* tfout = new TFile(rootname,"recreate");



  TNtuple* runcard = new TNtuple("runcard","runcard","i:repeat:xi:yi:zi:ekin:thetai:phii:mass:charge:nscatters:mean:sigma:height:emean:esigma:eheight:chi2");
  float ntarray[20];

  int N=parameter.fft_max_npts;
  double tstep = parameter.fft_resample_tstep;

  double* time_array = (double*) malloc(N*sizeof(double));
  for (int i=0;i<N;i++)
    {
      time_array[i] = i*tstep;
    }


  cout << "ready to run" << endl;
  while (runfile >> repeat >> xi >> yi >> zi >> ekin >> thetai >> phii >> mass >> charge)
    {
      cout << "running  " << i << endl;
      TString trackname = cardname+TString(".track");
      trackname += i;
      ifstream trackfile;
      trackfile.open(trackname.Data());
      
      //initialize fft
      double *in, *xin, *rout;
      fftw_complex  *out;
      fftw_plan p;
      in = (double*) fftw_malloc(sizeof(double) * N);
      xin = (double*) fftw_malloc(sizeof(double) * N);
/*       phiin = (double*) fftw_malloc(sizeof(double) * N); */
/*       xphi = (double*) fftw_malloc(sizeof(double) * N); */
      out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);
      rout = (double*) fftw_malloc(sizeof(double) * N);
      //      initialize output

      double lastphi=0;
      double lastt=0;
      long int it = 0;
      double thist = it*tstep; 
      double thisphi, dphidt;
      double thisx, dxdt;
      double thisy,thisz,dydt,dzdt;
      double lastx = 0;
      double lasty = 0;
      double lastz = 0;
      //In this loop we will take steps of length tstep (generated by it loop) and read lines of the track-report file whenever we need to.
      thisphi=0;
      thisx = 0;
      thisy = 0;
      thisz = 0;
      int iline=0;
      double laste = 0 ;
      int nscatters=0;
      while (trackfile >>  x >> y >> z >> r >> ep >> ek >> epar >> eperp >> egain >> eloss >> b >> phi >> t >> scatt >> wq)
	{
	  iline++;
	  dphidt = (phi-lastphi)/(t-lastt);
	  dxdt = (x - lastx)/(t-lastt);
	  dydt = (y - lasty)/(t-lastt);
	  dzdt = (z - lastz)/(t-lastt);
	  while (thist < t)
	    {
	      thisphi = lastphi + dphidt*(thist-lastt);	      
	      thisx = lastx + dxdt*(thist-lastt);
	      thisy = lasty + dydt*(thist-lastt);
	      thisz = lastz + dzdt*(thist-lastt);
	      //calculate radiation signal at antenna at this time
	      switch (parameter.rad_calc_mode)
		{
		case 0: in[it] = cos(M_PI/180*thisphi); break;
		case 1: 
		  double position[3], bvec[3], bvalue;
		  position[0] = thisx; position[1] = thisy;  position[2] = thisz; 
		  get_bfield(position,bvec);
		  bvalue = sqrt(bvec[0]*bvec[0]+bvec[1]*bvec[1]+bvec[2]*bvec[2]);
		  in[it] = antenna_at_infinity(thisphi,thisx,thisy,thisz,eperp,epar,bvalue)*cos(M_PI/180*thisphi);
		  break;
		}
		  
	      xin[it] = thisx;
	      //	      phiin[it] = phi;
	      //	      xphi[it] = x;
	      thist = it*tstep;
	      it++;
	      if (it >= N) break;
	    }
	  
	  if (laste - ek > 1.0) nscatters++ ; 
	  if (it >= N) break;
	  lastt = t;
	  lastphi = thisphi;
	  lastx = thisx;
	  lasty = thisy;
	  lastz = thisz;
	  laste = ek;
	}
      cout << "done making time series at iline " << iline << " t=" << thist <<endl;

      p = fftw_plan_dft_r2c_1d(TMath::Min(Long_t(N),it), in, out, FFTW_ESTIMATE);
      cout << "executing " << i << endl; 

      fftw_execute(p); 

      cout << "done fft" << i << endl; 
      trackfile.close();


      cout << "prepare ntuple " << i << " " << N << " " << it << endl; 
      TString ntname="nt_";
      ntname+=i;
      TNtuple* nt = new TNtuple(ntname,ntname,"t:m:in:x");
      for (int j=0;j<TMath::Min(Long_t(N),it);j++)
	{
	  rout[j] = sqrt(pow(out[j][0],2)+pow(out[j][1],2));
	  nt->Fill(j*tstep,rout[j],in[j],xin[j]);	  	  
	}
      
      double pars[7];     
      double* freq_array = (double*) malloc(N*sizeof(double));
      double delf = 1e6/lastt;//in Hz
      for (int k=0;k<N;k++)
        {
          freq_array[k] = k*delf;
        }

      //      fit_fft_to_gaussian(pars,time_array,rout,TMath::Min(Long_t(N),it));
      fit_fft_to_lorentzian(pars,freq_array,rout,TMath::Min(Long_t(N),it)) ;     
      ntarray[0] = i;
      ntarray[1] = repeat;
      ntarray[2] = xi;
      ntarray[3] = yi;
      ntarray[4] = zi;
      ntarray[5] = ekin;
      ntarray[6] = thetai;
      ntarray[7] = phii;
      ntarray[8] = mass;
      ntarray[9] = charge;
      ntarray[10] = nscatters;
      ntarray[11] = pars[0];
      ntarray[12] = pars[1];
      ntarray[13] = pars[2];
      ntarray[14] = pars[3];
      ntarray[15] = pars[4];
      ntarray[16] = pars[5];
      ntarray[17] = pars[6];

      runcard->Fill(ntarray);
      nt->Write();
      cout << "done w/ loop " << i << endl;

      cout << "freeing " << i << endl; 
      fftw_destroy_plan(p);
      fftw_free(in); 
      fftw_free(xin); 
      fftw_free(out);
      fftw_free(rout);

      i++;
    }

  runcard->Write();
  tfout->Close();
  
}
